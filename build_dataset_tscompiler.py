import argparse
import json
import os
import sys
import random
from dataclasses import dataclass
from typing import Dict, Iterable, List, Optional, Tuple


@dataclass(frozen=True)
class Fn:
    id: str
    code: str
    file: str
    start_line: int
    end_line: int
    name: str
    kind: str


def iter_jsonl(path: str) -> Iterable[dict]:
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            yield json.loads(line)


def load_functions(callgraph_jsonl: str) -> Tuple[Dict[str, Fn], List[dict]]:
    fns: Dict[str, Fn] = {}
    rows: List[dict] = []
    for row in iter_jsonl(callgraph_jsonl):
        rows.append(row)
        fns[row["id"]] = Fn(
            id=row["id"],
            code=row.get("code", ""),
            file=row.get("file", ""),
            start_line=int(row.get("start_line", 0)),
            end_line=int(row.get("end_line", 0)),
            name=row.get("name", ""),
            kind=row.get("kind", ""),
        )
    return fns, rows


def build_index_by_file(fns: Dict[str, Fn]) -> Dict[str, List[Fn]]:
    by_file: Dict[str, List[Fn]] = {}
    for fn in fns.values():
        by_file.setdefault(fn.file, []).append(fn)
    for file_path, items in by_file.items():
        items.sort(key=lambda x: (x.start_line, x.end_line, x.id))
    return by_file


def pick_negative(source: Fn, target: Fn, by_file: Dict[str, List[Fn]], all_fns: List[Fn]) -> Optional[Fn]:
    excluded = {source.id, target.id}
    sib = [fn for fn in by_file.get(source.file, []) if fn.id not in excluded]
    if sib:
        return sib[0]
    src_dir = os.path.dirname(source.file)
    near = [fn for fn in all_fns if fn.id not in excluded and os.path.dirname(fn.file) == src_dir]
    near.sort(key=lambda x: (x.file, x.start_line, x.id))
    if near:
        return near[0]
    any_fn = [fn for fn in all_fns if fn.id not in excluded]
    if not any_fn:
        return None
    any_fn.sort(key=lambda x: (x.file, x.start_line, x.id))
    return any_fn[0]


def build_pairs(callgraph_jsonl: str, out_jsonl: str, with_negative: bool = True) -> int:
    fns, rows = load_functions(callgraph_jsonl)
    by_file = build_index_by_file(fns)
    all_fns = list(fns.values())

    emitted = set()
    n = 0
    out_f = None
    if out_jsonl == "-":
        out_f = sys.stdout
    else:
        out_dir = os.path.dirname(out_jsonl)
        if out_dir:
            os.makedirs(out_dir, exist_ok=True)
        out_f = open(out_jsonl, "w", encoding="utf-8")

    with out_f as out:
        for row in rows:
            src_id = row["id"]
            src_fn = fns.get(src_id)
            if not src_fn or not src_fn.code:
                continue
            for call in row.get("calls", []):
                tgt_id = call.get("target_id")
                if not tgt_id:
                    continue
                tgt_fn = fns.get(tgt_id)
                if not tgt_fn or not tgt_fn.code:
                    continue
                key = (src_id, tgt_id, call.get("expr", ""))
                if key in emitted:
                    continue
                emitted.add(key)

                payload = {
                    "query": src_fn.code,
                    "positive": tgt_fn.code,
                    "meta": {
                        "type": "call_relationship",
                        "call": call.get("expr", ""),
                        "source_id": src_id,
                        "target_id": tgt_id,
                        "source_file": src_fn.file,
                        "target_file": tgt_fn.file,
                    },
                }
                if with_negative:
                    neg = pick_negative(src_fn, tgt_fn, by_file, all_fns)
                    if not neg or not neg.code:
                        continue
                    payload["negative"] = neg.code
                out.write(json.dumps(payload, ensure_ascii=False) + "\n")
                n += 1
    return n


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--callgraph", required=True, help="Path to callgraph jsonl generated by TS compiler extractor")
    ap.add_argument("--out", required=True, help="Output pairs jsonl path")
    ap.add_argument("--no-negative", action="store_true", help="Do not emit negative samples")
    args = ap.parse_args()

    count = build_pairs(args.callgraph, args.out, with_negative=not args.no_negative)
    print(count)


if __name__ == "__main__":
    main()

